<VisualMicro>
  <Program Name="PondMonitor4" Ext=".ino" Location="C:\Users\jimfr\Documents\GitHub\PondMonitor4\PondMonitor4">
    <Compile IsDebugStart="1" CompilerErrors="0" ConfigurationName="Debug" StopOnError="False" OptimiseLibs="True" OptimiseCore="True" ReCompileIfSourceIsNewer="1" BuildPath="C:\Users\jimfr\AppData\Local\Temp\VMicroBuilds\PondMonitor4\mega_atmega2560" SketchName="PondMonitor4" ReportDigitalPins="0" ReportAnalogPins="0" ReportI2C="0" ReportFreeMemory="0" IncludeDebug="1" LastDebugPreProcessorDefinitions="VM_DEBUG;VM_DEBUG_ENABLE 1;VM_DEBUG_BANDWIDTH_THROTTLE_MS 100;VM_DEBUGGER_TYPE_HARDWARESERIAL 0;VM_DEBUGGER_TYPE_SOFTWARESERIAL 1;VM_DEBUGGER_TYPE_FASTSERIAL 2;VM_DEBUGGER_TYPE_USB 3;VM_DEBUGGER_TYPE_TEENSY 4;VM_DEBUGGER_TYPE_UART 5;VM_DEBUGGER_TYPE_USART 6;VM_DEBUGGER_TYPE_USBSERIAL 7;VM_DEBUGGER_TYPE_TTYUART 8;VM_DEBUGGER_TYPE_NET_CONSOLE 9;VM_DEBUGGER_TYPE_Uart 10;VM_DEBUGGER_TYPE_COSA 11;VM_DEBUGGER_TYPE_CDCSerialClass 12;VM_DEBUGGER_TYPE_HARDWARESERIAL1 13;VM_DEBUGGER_TYPE_HARDWARESERIAL2 14;VM_DEBUGGER_TYPE_HARDWARESERIAL3 15;VM_DEBUGGER_TYPE VM_DEBUGGER_TYPE_HARDWARESERIAL;VM_DEBUG_BREAKPAUSE;" IncludesDebug="1" IsCompiled="1" />
    <Platform Name="arduino16x" Package="arduino" Platform="avr" Architecture="avr">
      <Board Name="mega_atmega2560" Description="Arduino/Genuino Mega w/ ATmega2560 (Mega 2560)" CoreFolder="C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino" VariantFullPath="C:\Program Files (x86)\Arduino\hardware\arduino\avr\variants\mega" McuIdePath="C:\Program Files (x86)\Arduino" McuSketchBookPath="C:\Users\jimfr\Documents\GitHub" name="Arduino/Genuino Mega w/ ATmega2560 (Mega 2560)" vid.0="0x2341" pid.0="0x0010" vid.1="0x2341" pid.1="0x0042" vid.2="0x2A03" pid.2="0x0010" vid.3="0x2A03" pid.3="0x0042" vid.4="0x2341" pid.4="0x0210" vid.5="0x2341" pid.5="0x0242" upload.tool="avrdude" upload.maximum_data_size="8192" bootloader.tool="avrdude" bootloader.low_fuses="0xFF" bootloader.unlock_bits="0x3F" bootloader.lock_bits="0x0F" build.f_cpu="16000000L" build.core="arduino" build.variant="mega" build.board="AVR_MEGA2560" menu.cpu.atmega2560="ATmega2560 (Mega 2560)" menu.cpu.atmega2560.upload.protocol="wiring" menu.cpu.atmega2560.upload.maximum_size="253952" menu.cpu.atmega2560.upload.speed="115200" menu.cpu.atmega2560.bootloader.high_fuses="0xD8" menu.cpu.atmega2560.bootloader.extended_fuses="0xFD" menu.cpu.atmega2560.bootloader.file="stk500v2/stk500boot_v2_mega2560.hex" menu.cpu.atmega2560.build.mcu="atmega2560" menu.cpu.atmega2560.build.board="AVR_MEGA2560" menu.cpu.atmega1280="ATmega1280" menu.cpu.atmega1280.upload.protocol="arduino" menu.cpu.atmega1280.upload.maximum_size="126976" menu.cpu.atmega1280.upload.speed="57600" menu.cpu.atmega1280.bootloader.high_fuses="0xDA" menu.cpu.atmega1280.bootloader.extended_fuses="0xF5" menu.cpu.atmega1280.bootloader.file="atmega/ATmegaBOOT_168_atmega1280.hex" menu.cpu.atmega1280.build.mcu="atmega1280" menu.cpu.atmega1280.build.board="AVR_MEGA" runtime.ide.path="C:\Program Files (x86)\Arduino" runtime.os="windows" build.system.path="C:\Program Files (x86)\Arduino\hardware\arduino\avr\system" runtime.ide.version="106011" target_package="arduino" target_platform="avr" runtime.hardware.path="C:\Program Files (x86)\Arduino\hardware\arduino" originalid="mega" intellisense.tools.path="{runtime.tools.avr-gcc.path}/" intellisense.include.paths="{intellisense.tools.path}avr/include/;{intellisense.tools.path}/avr/include/avr/;{intellisense.tools.path}lib\gcc\avr\4.8.1\include" tools.atprogram.cmd.path="%AVRSTUDIO_EXE_PATH%\atbackend\atprogram" tools.atprogram.cmd.setwinpath="true" tools.atprogram.program.params.verbose="-v" tools.atprogram.program.params.quiet="-q" tools.atprogram.program.pattern="&quot;{cmd.path}&quot; -d {build.mcu} {program.verbose} {program.extra_params} program -c -f &quot;{build.path}\{build.project_name}.hex&quot;" tools.atprogram.program.xpattern="&quot;{cmd.path}&quot; {AVRSTUDIO_BACKEND_CONNECTION} -d {build.mcu} {program.verbose} {program.extra_params} program -c -f &quot;{build.path}\{build.project_name}.hex&quot;" tools.atprogram.erase.params.verbose="-v" tools.atprogram.erase.params.quiet="-q" tools.atprogram.bootloader.params.verbose="-v" tools.atprogram.bootloader.params.quiet="-q" tools.atprogram.bootloader.pattern="&quot;{cmd.path}&quot; -d {build.mcu} {bootloader.verbose}  program -c -f &quot;{runtime.ide.path}/hardware/arduino/avr/bootloaders/{bootloader.file}&quot;" version="1.6.13" compiler.warning_flags="-w" compiler.warning_flags.none="-w" compiler.warning_flags.default="" compiler.warning_flags.more="-Wall" compiler.warning_flags.all="-Wall -Wextra" compiler.path="{runtime.tools.avr-gcc.path}/bin/" compiler.c.cmd="avr-gcc" compiler.c.flags="-c -g -Os {compiler.warning_flags} -std=gnu11 -ffunction-sections -fdata-sections -MMD -flto -fno-fat-lto-objects" compiler.c.elf.flags="{compiler.warning_flags} -Os -flto -fuse-linker-plugin -Wl,--gc-sections" compiler.c.elf.cmd="avr-gcc" compiler.S.flags="-c -g -x assembler-with-cpp -flto" compiler.cpp.cmd="avr-g++" compiler.cpp.flags="-c -g -Os {compiler.warning_flags} -std=gnu++11 -fpermissive -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -MMD -flto" compiler.ar.cmd="avr-gcc-ar" compiler.ar.flags="rcs" compiler.objcopy.cmd="avr-objcopy" compiler.objcopy.eep.flags="-O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0" compiler.elf2hex.flags="-O ihex -R .eeprom" compiler.elf2hex.cmd="avr-objcopy" compiler.ldflags="" compiler.size.cmd="avr-size" build.extra_flags="" compiler.c.extra_flags="" compiler.c.elf.extra_flags="" compiler.S.extra_flags="" compiler.cpp.extra_flags="" compiler.ar.extra_flags="" compiler.objcopy.eep.extra_flags="" compiler.elf2hex.extra_flags="" recipe.c.o.pattern="&quot;{compiler.path}{compiler.c.cmd}&quot; {compiler.c.flags} -mmcu={build.mcu} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.c.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.cpp.o.pattern="&quot;{compiler.path}{compiler.cpp.cmd}&quot; {compiler.cpp.flags} -mmcu={build.mcu} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.cpp.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.S.o.pattern="&quot;{compiler.path}{compiler.c.cmd}&quot; {compiler.S.flags} -mmcu={build.mcu} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.S.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" archive_file_path="{build.path}/{archive_file}" recipe.ar.pattern="&quot;{compiler.path}{compiler.ar.cmd}&quot; {compiler.ar.flags} {compiler.ar.extra_flags} &quot;{archive_file_path}&quot; &quot;{object_file}&quot;" recipe.c.combine.pattern="&quot;{compiler.path}{compiler.c.elf.cmd}&quot; {compiler.c.elf.flags} -mmcu={build.mcu} {compiler.c.elf.extra_flags} -o &quot;{build.path}/{build.project_name}.elf&quot; {object_files} &quot;{build.path}/{archive_file}&quot; &quot;-L{build.path}&quot; -lm" recipe.objcopy.eep.pattern="&quot;{compiler.path}{compiler.objcopy.cmd}&quot; {compiler.objcopy.eep.flags} {compiler.objcopy.eep.extra_flags} &quot;{build.path}/{build.project_name}.elf&quot; &quot;{build.path}/{build.project_name}.eep&quot;" recipe.objcopy.hex.pattern="&quot;{compiler.path}{compiler.elf2hex.cmd}&quot; {compiler.elf2hex.flags} {compiler.elf2hex.extra_flags} &quot;{build.path}/{build.project_name}.elf&quot; &quot;{build.path}/{build.project_name}.hex&quot;" recipe.output.tmp_file="{build.project_name}.hex" recipe.output.save_file="{build.project_name}.{build.variant}.hex" recipe.size.pattern="&quot;{compiler.path}{compiler.size.cmd}&quot; -A &quot;{build.path}/{build.project_name}.elf&quot;" recipe.size.regex="^(?:\.text|\.data|\.bootloader)\s+([0-9]+).*" recipe.size.regex.data="^(?:\.data|\.bss|\.noinit)\s+([0-9]+).*" recipe.size.regex.eeprom="^(?:\.eeprom)\s+([0-9]+).*" preproc.includes.flags="-w -x c++ -M -MG -MP" recipe.preproc.includes="&quot;{compiler.path}{compiler.cpp.cmd}&quot; {compiler.cpp.flags} {preproc.includes.flags} -mmcu={build.mcu} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.cpp.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot;" preproc.macros.flags="-w -x c++ -E -CC" recipe.preproc.macros="&quot;{compiler.path}{compiler.cpp.cmd}&quot; {compiler.cpp.flags} {preproc.macros.flags} -mmcu={build.mcu} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.cpp.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{preprocessed_file_path}&quot;" tools.avrdude.path="{runtime.tools.avrdude.path}" tools.avrdude.cmd.path="{path}/bin/avrdude" tools.avrdude.config.path="{path}/etc/avrdude.conf" tools.avrdude.upload.params.verbose="-v" tools.avrdude.upload.params.quiet="-q -q" tools.avrdude.upload.params.noverify="-V" tools.avrdude.upload.pattern="&quot;{cmd.path}&quot; &quot;-C{config.path}&quot; {upload.verbose} {upload.verify} -p{build.mcu} -c{upload.protocol} -P{serial.port} -b{upload.speed} -D &quot;-Uflash:w:{build.path}/{build.project_name}.hex:i&quot;" tools.avrdude.program.params.verbose="-v" tools.avrdude.program.params.quiet="-q -q" tools.avrdude.program.params.noverify="-V" tools.avrdude.program.pattern="&quot;{cmd.path}&quot; &quot;-C{config.path}&quot; {program.verbose} {program.verify} -p{build.mcu} -c{protocol} {program.extra_params} &quot;-Uflash:w:{build.path}/{build.project_name}.hex:i&quot;" tools.avrdude.erase.params.verbose="-v" tools.avrdude.erase.params.quiet="-q -q" tools.avrdude.erase.pattern="&quot;{cmd.path}&quot; &quot;-C{config.path}&quot; {erase.verbose} -p{build.mcu} -c{protocol} {program.extra_params} -e -Ulock:w:{bootloader.unlock_bits}:m -Uefuse:w:{bootloader.extended_fuses}:m -Uhfuse:w:{bootloader.high_fuses}:m -Ulfuse:w:{bootloader.low_fuses}:m" tools.avrdude.bootloader.params.verbose="-v" tools.avrdude.bootloader.params.quiet="-q -q" tools.avrdude.bootloader.pattern="&quot;{cmd.path}&quot; &quot;-C{config.path}&quot; {bootloader.verbose} -p{build.mcu} -c{protocol} {program.extra_params} &quot;-Uflash:w:{runtime.platform.path}/bootloaders/{bootloader.file}:i&quot; -Ulock:w:{bootloader.lock_bits}:m" tools.avrdude_remote.upload.pattern="/usr/bin/run-avrdude /tmp/sketch.hex {upload.verbose} -p{build.mcu}" build.usb_manufacturer="&quot;Unknown&quot;" build.usb_flags="-DUSB_VID={build.vid} -DUSB_PID={build.pid} '-DUSB_MANUFACTURER={build.usb_manufacturer}' '-DUSB_PRODUCT={build.usb_product}'" vm.platform.root.path="C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE\Extensions\nohrlvr1.3ka\Micro Platforms\arduino16x" avrisp.name="AVR ISP" avrisp.communication="serial" avrisp.protocol="stk500v1" avrisp.program.protocol="stk500v1" avrisp.program.tool="avrdude" avrisp.program.extra_params="-P{serial.port}" avrispmkii.name="AVRISP mkII" avrispmkii.communication="usb" avrispmkii.protocol="stk500v2" avrispmkii.program.protocol="stk500v2" avrispmkii.program.tool="avrdude" avrispmkii.program.extra_params="-Pusb" usbtinyisp.name="USBtinyISP" usbtinyisp.protocol="usbtiny" usbtinyisp.program.tool="avrdude" usbtinyisp.program.extra_params="" arduinoisp.name="ArduinoISP" arduinoisp.protocol="arduinoisp" arduinoisp.program.tool="avrdude" arduinoisp.program.extra_params="" usbasp.name="USBasp" usbasp.communication="usb" usbasp.protocol="usbasp" usbasp.program.protocol="usbasp" usbasp.program.tool="avrdude" usbasp.program.extra_params="-Pusb" parallel.name="Parallel Programmer" parallel.protocol="dapa" parallel.force="true" parallel.program.tool="avrdude" parallel.program.extra_params="-F" arduinoasisp.name="Arduino as ISP" arduinoasisp.communication="serial" arduinoasisp.protocol="stk500v1" arduinoasisp.speed="19200" arduinoasisp.program.protocol="stk500v1" arduinoasisp.program.speed="19200" arduinoasisp.program.tool="avrdude" arduinoasisp.program.extra_params="-P{serial.port} -b{program.speed}" usbGemma.name="Arduino Gemma" usbGemma.protocol="arduinogemma" usbGemma.program.tool="avrdude" usbGemma.program.extra_params="" usbGemma.config.path="{runtime.platform.path}/bootloaders/gemma/avrdude.conf" stk500.name="Atmel STK500 development board" stk500.communication="serial" stk500.protocol="stk500" stk500.program.protocol="stk500" stk500.program.tool="avrdude" stk500.program.extra_params="-P{serial.port}" buspirate.name="BusPirate as ISP" buspirate.communication="serial" buspirate.protocol="buspirate" buspirate.program.protocol="buspirate" buspirate.program.tool="avrdude" buspirate.program.extra_params="-P{serial.port}" runtime.tools.avrdude.path="C:\Program Files (x86)\Arduino\hardware\tools\avr" runtime.tools.avrdude-6.0.1-arduino5.path="C:\Program Files (x86)\Arduino\hardware\tools\avr" runtime.tools.avr-gcc.path="C:\Program Files (x86)\Arduino\hardware\tools\avr" runtime.tools.avr-gcc-4.9.2-atmel3.5.3-arduino2.path="C:\Program Files (x86)\Arduino\hardware\tools\avr" upload.protocol="wiring" upload.maximum_size="253952" upload.speed="115200" bootloader.high_fuses="0xD8" bootloader.extended_fuses="0xFD" bootloader.file="stk500v2/stk500boot_v2_mega2560.hex" build.mcu="atmega2560" runtime.vm.boardinfo.id="mega_atmega2560" runtime.vm.boardinfo.name="mega_atmega2560" runtime.vm.boardinfo.desc="Arduino/Genuino Mega w/ ATmega2560 (Mega 2560)" runtime.vm.boardinfo.src_location="C:\Program Files (x86)\Arduino\hardware\arduino\avr" ide.hint="For all platforms that use Board Manager" ide.location.key="Arduino16x" ide.location.ide.winreg="Arduino 1.6.x Application" ide.location.sketchbook.winreg="Arduino 1.6.x Sketchbook" ide.location.sketchbook.preferences="sketchbook.path" ide.default.revision_name="1.6.9" ide.default.version="10609" ide.default.package="arduino" ide.default.platform="avr" ide.multiplatform="true" ide.includes="arduino.h" ide.exe_name="arduino" ide.platformswithoutpackage="false" ide.includes.fallback="wprogram.h" ide.extension="ino" ide.extension.fallback="pde" ide.versionGTEQ="160" ide.exe="arduino.exe" ide.hosts="atmel" ide.url="http://arduino.cc/en/Main/Software" ide.help.reference.path="reference\arduino.cc\en\Reference" ide.help.reference.path2="reference\www.arduino.cc\en\Reference" ide.help.reference.serial="reference\www.arduino.cc\en\Serial" vm.debug="true" software="ARDUINO" ssh.user.name="root" ssh.user.default.password="arduino" ssh.host.wwwfiles.path="/www/sd" build.working_directory="{runtime.ide.path}" ide.location.preferences.portable="{runtime.ide.path}\portable" ide.location.preferences="%VM_APPDATA_LOCAL%\arduino15\preferences.txt" ide.location.preferences_fallback="%VM_APPDATA_ROAMING%\arduino15\preferences.txt" ide.location.contributions="%VM_APPDATA_LOCAL%\arduino15" ide.location.contributions_fallback="%VM_APPDATA_ROAMING%\arduino15" ide.contributions.boards.allow="true" ide.contributions.boards.ignore_unless_rewrite_found="true" ide.contributions.libraries.allow="true" ide.contributions.boards.support.urls.wiki="https://github.com/arduino/Arduino/wiki/Unofficial-list-of-3rd-party-boards-support-urls" ide.create_platforms_from_boardsTXT.teensy="build.core" ide.appid="arduino16x" location.sketchbook="C:\Users\jimfr\Documents\GitHub" build.core.vmresolved="C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino" build.core.parentfolder.vmresolved="C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores" build.core.coresparentfolder.vmresolved="C:\Program Files (x86)\Arduino\hardware\arduino\avr" build.core.path="C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino" vm.core.include="arduino.h" vm.boardsource.path="C:\Program Files (x86)\Arduino\hardware\arduino\avr" runtime.platform.path="C:\Program Files (x86)\Arduino\hardware\arduino\avr" vm.platformname.name="avr" build.arch="AVR" build.variant.vmresolved="C:\Program Files (x86)\Arduino\hardware\arduino\avr\variants\mega" build.architecture="avr" vmresolved.compiler.path="C:\Program Files (x86)\Arduino\hardware\tools\avr\bin\" vmresolved.tools.path="C:\Program Files (x86)\Arduino\hardware\tools\avr" vm.runtime.compiler.showwarnings="true" vm.runtime.upload.verbose="false" vm.runtime.upload.verify="false" vm.runtime.compiler.auto_discover_includes="true" vm.last.buildpath="C:\Users\jimfr\AppData\Local\Temp\VMicroBuilds\PondMonitor4\mega_atmega2560" />
    </Platform>
    <Debug EnableBreak="1" DebugEnabled="1" IsGdb="0" RemotePortSpeedWrittenToDebugSource="115200" />
    <VCCodeModel>
      <VCCodeMacros />
    </VCCodeModel>
    <BreakPoints>
      <BreakPoint Index="1" Name="PondMonitor4.ino, line 2409" Id="dcea8490-fb8b-4d48-8f09-1f8683dc92d9" Enabled="0" Message="temp sensors = {tempString}" MessageTextType="0" PreProcessedMessage="temp sensors = {0}" Condition="" ConditionType="1" CurrentHits="0" File="c:\users\jimfr\documents\github\pondmonitor4\pondmonitor4\pondmonitor4.ino" FileLine="2409" FileColumn="1" FunctionName="ReadWaterLvlSensor(void)" FunctionLineOffset="5" FunctionColumnOffset="1" HitCountTarget="1" HitCountType="1" Language="C++" LocationType="3" Tag="&lt;vmbp Id='dcea8490-fb8b-4d48-8f09-1f8683dc92d9'/&gt;" Type="1" ToString="System.__ComObject" BreakWhenHit="0">
        <Source>2402	};
2403	//----------------------------------------------------------------------
2404	void	WaterLvlSensor::ReadWaterLvlSensor(void)
2405	{
2406		// called at polling intervals (WaterLvlPollRedirect is called at intervals set up by TurnOn and calls the routing. See SensorPollRedirect for expalination of need for indirection
2407		// based on the value of ReadDelay, This routine either turns on the power to the moisture sensor, sets the delay before reading.
2408		// or reads the water level sensor, sets results and flags indicating a reading is ready for use, and resets polling interval
--&gt;2409	
2410		if (!(ReadDelay))
2411		{
2412			//time to read the moisture level.  However, the power needs to be turned on and we need to wait for the sensor to settle.  The delay is set here
2413			ReadDelay = true;	// flag we are entering the power up delay
2414			digitalWrite(WaterLvlPowerPin, HIGH);	// turn on power
2415			PowerDelayContext = SensTmr.after(WaterLvlReadDelay, WaterLvlPollRedirect, (void*)5);	//	return to WaterLvlPollRedirect after power up delay
2416		}
2417		else
2418		{
</Source>
        <MessageVariables>
          <MessageVariable Name="tempString" Index="1" />
        </MessageVariables>
      </BreakPoint>
      <BreakPoint Index="2" Name="PondMonitor4.ino, line 2411" Id="872e90b2-c1a6-4ac2-a18f-deae598d0525" Enabled="0" Message="flow sensors = {tempString}" MessageTextType="0" PreProcessedMessage="flow sensors = {0}" Condition="" ConditionType="1" CurrentHits="0" File="c:\users\jimfr\documents\github\pondmonitor4\pondmonitor4\pondmonitor4.ino" FileLine="2411" FileColumn="1" FunctionName="ReadWaterLvlSensor(void)" FunctionLineOffset="7" FunctionColumnOffset="1" HitCountTarget="1" HitCountType="1" Language="C++" LocationType="3" Tag="&lt;vmbp Id='872e90b2-c1a6-4ac2-a18f-deae598d0525'/&gt;" Type="1" ToString="System.__ComObject" BreakWhenHit="0">
        <Source>2404	void	WaterLvlSensor::ReadWaterLvlSensor(void)
2405	{
2406		// called at polling intervals (WaterLvlPollRedirect is called at intervals set up by TurnOn and calls the routing. See SensorPollRedirect for expalination of need for indirection
2407		// based on the value of ReadDelay, This routine either turns on the power to the moisture sensor, sets the delay before reading.
2408		// or reads the water level sensor, sets results and flags indicating a reading is ready for use, and resets polling interval
2409	
2410		if (!(ReadDelay))
--&gt;2411		{
2412			//time to read the moisture level.  However, the power needs to be turned on and we need to wait for the sensor to settle.  The delay is set here
2413			ReadDelay = true;	// flag we are entering the power up delay
2414			digitalWrite(WaterLvlPowerPin, HIGH);	// turn on power
2415			PowerDelayContext = SensTmr.after(WaterLvlReadDelay, WaterLvlPollRedirect, (void*)5);	//	return to WaterLvlPollRedirect after power up delay
2416		}
2417		else
2418		{
2419			//power up delay is done, 
2420			ReadDelay = false;	// flag that power up delay is over
</Source>
        <MessageVariables>
          <MessageVariable Name="tempString" Index="1" />
        </MessageVariables>
      </BreakPoint>
      <BreakPoint Index="3" Name="PondMonitor4.ino, line 2413" Id="640be496-9657-4042-85d3-6ff2d91b16bd" Enabled="0" Message="water lvl sensors = {tempString}" MessageTextType="0" PreProcessedMessage="water lvl sensors = {0}" Condition="" ConditionType="1" CurrentHits="0" File="c:\users\jimfr\documents\github\pondmonitor4\pondmonitor4\pondmonitor4.ino" FileLine="2413" FileColumn="1" FunctionName="ReadWaterLvlSensor(void)" FunctionLineOffset="9" FunctionColumnOffset="1" HitCountTarget="1" HitCountType="1" Language="C++" LocationType="3" Tag="&lt;vmbp Id='640be496-9657-4042-85d3-6ff2d91b16bd'/&gt;" Type="1" ToString="System.__ComObject" BreakWhenHit="0">
        <Source>2406		// called at polling intervals (WaterLvlPollRedirect is called at intervals set up by TurnOn and calls the routing. See SensorPollRedirect for expalination of need for indirection
2407		// based on the value of ReadDelay, This routine either turns on the power to the moisture sensor, sets the delay before reading.
2408		// or reads the water level sensor, sets results and flags indicating a reading is ready for use, and resets polling interval
2409	
2410		if (!(ReadDelay))
2411		{
2412			//time to read the moisture level.  However, the power needs to be turned on and we need to wait for the sensor to settle.  The delay is set here
--&gt;2413			ReadDelay = true;	// flag we are entering the power up delay
2414			digitalWrite(WaterLvlPowerPin, HIGH);	// turn on power
2415			PowerDelayContext = SensTmr.after(WaterLvlReadDelay, WaterLvlPollRedirect, (void*)5);	//	return to WaterLvlPollRedirect after power up delay
2416		}
2417		else
2418		{
2419			//power up delay is done, 
2420			ReadDelay = false;	// flag that power up delay is over
2421			PriorLvlRange = WaterLvlRange;	//save prior water level.  Needed to determine if level increasing or decreasing
2422			WaterLvl = analogRead(WaterLvlInput);	//read water level analog input
</Source>
        <MessageVariables>
          <MessageVariable Name="tempString" Index="1" />
        </MessageVariables>
      </BreakPoint>
      <BreakPoint Index="4" Name="PondMonitor4.ino, line 2415" Id="ec618eb6-660a-4fbf-bf25-f0d30017a095" Enabled="0" Message="pumpMode = {PumpMode}" MessageTextType="0" PreProcessedMessage="pumpMode = {0}" Condition="" ConditionType="1" CurrentHits="0" File="c:\users\jimfr\documents\github\pondmonitor4\pondmonitor4\pondmonitor4.ino" FileLine="2415" FileColumn="1" FunctionName="ReadWaterLvlSensor(void)" FunctionLineOffset="11" FunctionColumnOffset="1" HitCountTarget="1" HitCountType="1" Language="C++" LocationType="3" Tag="&lt;vmbp Id='ec618eb6-660a-4fbf-bf25-f0d30017a095'/&gt;" Type="1" ToString="System.__ComObject" BreakWhenHit="0">
        <Source>2408		// or reads the water level sensor, sets results and flags indicating a reading is ready for use, and resets polling interval
2409	
2410		if (!(ReadDelay))
2411		{
2412			//time to read the moisture level.  However, the power needs to be turned on and we need to wait for the sensor to settle.  The delay is set here
2413			ReadDelay = true;	// flag we are entering the power up delay
2414			digitalWrite(WaterLvlPowerPin, HIGH);	// turn on power
--&gt;2415			PowerDelayContext = SensTmr.after(WaterLvlReadDelay, WaterLvlPollRedirect, (void*)5);	//	return to WaterLvlPollRedirect after power up delay
2416		}
2417		else
2418		{
2419			//power up delay is done, 
2420			ReadDelay = false;	// flag that power up delay is over
2421			PriorLvlRange = WaterLvlRange;	//save prior water level.  Needed to determine if level increasing or decreasing
2422			WaterLvl = analogRead(WaterLvlInput);	//read water level analog input
2423			digitalWrite(WaterLvlPowerPin, LOW);	// turn power off
2424	
</Source>
        <MessageVariables>
          <MessageVariable Name="PumpMode" Index="1" />
        </MessageVariables>
      </BreakPoint>
      <BreakPoint Index="5" Name="PondMonitor4.ino, line 2459" Id="3aa585ff-de23-46f5-8e77-3adcf4e33840" Enabled="0" Message="temp polling in sec={tempInt}" MessageTextType="0" PreProcessedMessage="temp polling in sec={0}" Condition="" ConditionType="1" CurrentHits="0" File="c:\users\jimfr\documents\github\pondmonitor4\pondmonitor4\pondmonitor4.ino" FileLine="2459" FileColumn="1" FunctionName="" FunctionLineOffset="1" FunctionColumnOffset="1" HitCountTarget="1" HitCountType="1" Language="C++" LocationType="3" Tag="&lt;vmbp Id='3aa585ff-de23-46f5-8e77-3adcf4e33840'/&gt;" Type="1" ToString="System.__ComObject" BreakWhenHit="0">
        <Source>2452		WaterSens.ReadWaterLvlSensor();	//read the water level sensor
2453	}
2454	//--------------------------------------------Relay Board variables and class -------------------------------------
2455	class RelayBoard
2456	{
2457		/*
2458		class for Relay module board. Board is made by ### jf here ### and has 4 relays, each activated by a digital pin going low.
--&gt;2459	
2460		*/
2461	protected:
2462		boolean	Relay1wiredNO;		//if true then wired as NO (normally open) and circuit is off when relay is off, else wired as NC (normally closed=circuit on when relay is off)
2463		boolean	Relay2wiredNO;
2464		boolean	Relay3wiredNO;
2465		boolean	Relay4wiredNO;
2466		boolean Relay1State;		//logical on/of state of circuit attached to relay
2467		boolean Relay2State;
2468		boolean Relay3State;
</Source>
        <MessageVariables>
          <MessageVariable Name="tempInt" Index="1" />
        </MessageVariables>
      </BreakPoint>
    </BreakPoints>
  </Program>
</VisualMicro>